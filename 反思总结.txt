1.目标检测数据标注问题：符合条件的一定要标注，不要漏标错标
2.图片尺寸：看看要不要做缩放或者裁剪，这个canovn相机拍摄的数据实在太大了
3.计算数据分布形式：通过compute_mean_std计算数据的均值和方差，以更加贴切的完成数据归一化等预处理工作
4.关键点检测数据标注问题：不仅只能标注单目标的小图，而且各关键点标注顺序尽量一致
5.画热力图：utils即每个关键点对应一张热力图，再将几张热力图合并为一张，即为原图对应的热力图
6.读取记载数据集：datasets_v2，6P，读取原图和json文件中的关键点信息，然后画热力图（实际上输入网络的就是原图和热力图？）
7.坐标回归：关键点坐标加上关键点所在目标框的左上角坐标即可得到原图的坐标
8.固化：为了方便部署，时常将语义分割网络训练权重pth用jit转pt，将目标检测网络训练权重pt用export转torchscript
这样固化后的权重极为带模型的权重文件，在推理或使用的时候可以直接通过torch.jit.load加载模型和权重，
而无需单独去寻找并加载模型。



# 好滴！很简单我现在就来讲讲思路：
# （1）数据准备：准备目标检测推理后裁剪输出的图片，用labelme标注json格式关键点，注意最好是标注顺序一一对应
# （2）网络模型：unet.py,要换网络架构模型直接换一个完整的网络.py就可以，换什么都可以注意最后输出通道数为6就可以了
# （好像是的，因为无非就是回归坐标换成了回归热力图，所以大胆尝试）
# （3）加载数据：datasets.py（utils.py）,读取图片和json文件，主要是读json文件，按照顺序获取关键点，并将关键点根据原图归一化缩放，
# 经由高斯画各个关键点的热力图，将六张热力图融合成一张含有六个热力点的热力图，最后返回图片和对应的热力图
# （4）模型训练：可以说和一般的网络几乎没有什么不同，loss就是网络输出和热力图之间的loss，shape都是(N,6,256,256)
# （5）模型推理：模型推理后得到的是一个(N,6,256,256)热力图，
#   通过get_peak_points函数获取热力图中的各个关键点的相对位置(N,6,2)即6个关键点的x，y坐标
# reshaope为(N,12)，分别计算六个关键点的真是坐标，即将归一化的坐标根据原图大小恢复，拿到6个关键点的真实坐标就把他画到原图上，就完了。
# 这么说来，其实一共就才5个py文件而且后续改也只需要改unet.py就可以了。